---
title: "Chapter 6 Practice"
author: "Jane Goodall"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
---


## Task 1

ğŸ¯ First I opened the help file

```{r}
# âš¡
# ?rnorm
```

ğŸ—£ In the Usage line, anything with an `=` shows a default value (optional), and anything without an `=` is required.

Here is the Usage line (copied from the help page):

`rnorm(n, mean = 0, sd = 1)`

- `n` is required (no `=`)

- `mean` and `sd` has a = sign showing the default values. 

ğŸ—£ I like this one because itâ€™s super clear. Like it literally tells you the â€œdefault normal distributionâ€ is mean 0 and sd 1 unless you change it. Also this is the first time Iâ€™m realizing the help file is basically R telling you â€œhereâ€™s what Iâ€™ll do if you donâ€™t specifiy stuff.â€


## Task 2

ğŸ¯ Build lab reading + insert 3 missing values

```{r}
# âš¡
set.seed(11)

lab_readings <- round(runif(n = 40, min = 0.20, max = 0.95), 2)
# labs_reading typo - fixed to lab_readings
na_pos <- sample(seq_along(lab_readings), size = 3, replace = FALSE)
lab_readings[na_pos] <- NA

length(lab_readings)     
sum(is.na(lab_readings)) 
lab_readings
```

ğŸ—£ This feels more â€œscience-yâ€ than the other one because these look like actual measurments (even tho theyâ€™re fake). I rounded them because otherwise you get like a million decimals and itâ€™s hard to read. Also I like that the `NA`s are in random spots (not just stuck at the end), because in real data you usually donâ€™t get missing values in a perfect pattern.

## Task 3

ğŸ¯ Count missing values + show how defaults affect results

```{r}
# âš¡
n_missing <- sum(is.na(lab_readings))
n_missing
```

```{r}
# âš¡
range_raw <- range(lab_readings)
range_raw
```

```{r}
# âš¡
range_clean <- range(lab_readings, na.rm = TRUE)
range_clean
```

ğŸ—£ This is kinda annoying but also makes sense. If R doesnâ€™t know a value, it canâ€™t promise what the range is. The â€œdefaultâ€ thing is really the whole point here: if I forget `na.rm = TRUE` it doesnâ€™t throw an error, it just gives me NA and I might be like â€œwelp.â€ So I need to actually check missingness on purpose.

## Task 4

ğŸ¯ Locate the missing positions (indices)

```{r}
# âš¡
is_missing <- is.na(lab_readings)
missing_positions <- seq_along(lab_readings)[is_missing]
```

```{r}
# âœ… Check
is_missing
missing_positions
length(missing_positions)
```

ğŸ—£ The logical vector is like a mask, which is pretty cool because itâ€™s the same length as the data and lines up position-by-position. Then the `seq_along(...)[mask]` thing basically turns the TRUE spots into index numbers. Also I noticed the missing ones are not at the end (because we inserted them randomly), which is more realistic and also harder because you actually have to go find them.

## Task 5

ğŸ¯ Nest `na.omit()` inside `sample()` so the sample cannot pull `NA` at all.

```{r}
# âš¡
set.seed(21)

mean_of_eight <- mean(sample(na.omit(lab_readings), size = 8, replace = TRUE))
sd_of_six <- sd(sample(na.omit(lab_readings), size = 6, replace = TRUE))

# âœ… Check
mean_of_eight
sd_of_six
```

ğŸ—£ Nesting is starting to click more now. Itâ€™s like: first remove the missing values (`na.omit()`), then sample, then feed that into `mean()` or `sd()`. I like this because it doesnâ€™t rely on me remembering `na.rm = TRUE` every time. It's like the missing values are gone before I even sample. Also sd feels a little â€œpickierâ€ than mean so it was good to test both.

## Task 6

ğŸ¯ Create two separate objects:

- `run_stamp` using `date()`

- `run_timezone` using `Sys.timezone()`

```{r}
# âš¡
run_stamp <- date()         
run_timezone <- Sys.timezone()

run_stamp
run_timezone
```

ğŸ—£ Ok this one surprised me because timezone is actually info I never think about until something breaks. But I can see why it matters if youâ€™re sharing files or working with other people. The date is also just nice for being like â€œwhen did I even do this.â€


## Task 7

### Part A

ğŸ¯ Create `lab_clean` by keeping only non-missing values in labs, then verify the lengths.

```{r}
# âš¡
lab_clean <- lab_readings[!is.na(lab_readings)]

# âœ… Checks
length(lab_readings)       
length(lab_clean) 

```

ğŸ—£ `lab_readings[!is.na(lab_readings)]` uses logical indexing to keep only values that are not missing, and `!` flips the `TRUE`/`FALSE` so the â€œgood valuesâ€ become `TRUE` and get kept.


### Part B

ğŸ¯ Make a copy `lab_imputed`, then replace missing values with the median of observed values, and verify missingness is gone.

```{r}
# âš¡
lab_imputed <- lab_readings

lab_imputed[is.na(lab_imputed)] <- median(lab_imputed, na.rm = TRUE)
```

```{r}
# âœ… Checks
sum(is.na(lab_imputed))
median(lab_imputed)
length(lab_imputed)
# moved length(lab_imputed) to this code block because it is after creating the lab_imputed variable.
```

ğŸ—£ Removing `NA`â€™s is the simplest, but itâ€™s also kinda like â€œpretend those people didnâ€™t existâ€ which might be bad depending on the study. Imputing feels weird too because youâ€™re filling in values that arenâ€™t real, but median feels less extreme than mean if thereâ€™s outliers. Also Iâ€™m glad we copy first because I would 100% overwrite it and then be like â€œwait what was the original.â€


## Task 8

Reflection

A function object (like `mean`) is the stored tool itself, but a function call (like `mean(lab_clean)`) is when you actually run the tool on specific data to get an output.

